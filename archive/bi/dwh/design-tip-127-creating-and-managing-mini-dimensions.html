

<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>Design Tip #127 Creating and Managing Mini-Dimensions</title>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta name="description">
		<meta name="application-name">
		<meta name="title">
		<link href="../../../favicon.ico" rel="shortcut icon" />
		<link rel="stylesheet" href="../../../resources/main.css">
	</head>
	

	<body>
	
		<div class="jumbotron1" id="jumbotron1">
			<div class="container">
				<h1 class="article-header">Design Tip #127 Creating and Managing Mini-Dimensions</h1>
				<div class="article-date">mi&#233;rcoles, 1 de septiembre de 2010</div>
			</div>
		</div>
	
		<hr id="anchor-point"/>
		<div class="container-fluid">
			<a href="../../../archive/bi/dwh/design-tip-127-creating-and-managing-mini-dimensions.html#" class="navigationBars">
				<div class="iconBars closed">
					<span id="icon-bar1" class="iconBar colorChange background"></span>
					<span id="icon-bar2" class="iconBar colorChange background"></span>
					<span id="icon-bar3" class="iconBar colorChange background"></span>
				</div>
			</a>
			<div class="navLinks">
				<a id="link1" class="colorChange navLink link1" href="../../../index.html">Home</a>
				<a class="iconLink" href="../../../index.html"><i title="Home" id="icon1" class="fa fa-home colorChange link1"></i></a>
	
				<a id="link2" class="colorChange navLink link2" href="../../../about.html">Sobre mi</a>
				<a class="iconLink" href="../../../about.html"><i title="Sobre mi" id="icon2" class="fa fa-envelope colorChange link2"></i></a>

				<a id="link2" class="colorChange navLink link3" href="../../../archive.html">Archivo</a>
				<a class="iconLink" href="../../../about.html"><i title="Archivo" id="icon3" class="fa fa-archive colorChange link3"></i></a>
			</div>			
			
			<div class="row">
				<div class="content col-sm-8 col-sm-offset-2 col-xs-10 col-xs-offset-1">
					<div class="article">
						<p class="article-description"></p>				
						<div class="article-content">
							<div class="pf-content">
							<p>This Design Tip describes how to create and manage mini-dimensions. Recall that a mini-dimension is a subset of attributes from a large dimension that tend to change rapidly, causing the dimension to grow excessively if changes were tracked using the Type 2 technique. By extracting unique combinations of these attribute values into a separate dimension, and joining this new mini-dimension directly to the fact table, the combination of attributes that were in place when the fact occurred are tied directly to the fact record.</p>
							<p><strong>Creating the Initial Mini-Dimension</strong><br>
							Once you identify the attributes you want to remove from the base dimension, the initial mini-dimension build is easily done using the brute force method in the relational database. Simply create a new table with a surrogate key column, and populate the table using a SELECT DISTINCT of the columns from the base dimension along with an IDENTITY field or SEQUENCE to create the surrogate key. For example, if you want to pull a set of demographic attributes out of the customer dimension, the following SQL will do the trick:</p>
							<p style="padding-left: 30px;">INSERT INTO Dim_Demographics<br>
							SELECT DISTINCT col 1, col2, â€¦<br>
							FROM Stage_Customer</p>
							<p>This may sound inefficient, but todayâ€™s database engines are pretty fast at this kind of query. Selecting an eight column mini-dimension with over 36,000 rows from a 26 column customer dimension with 1.1 million rows and no indexes took 15 seconds on a virtual machine running on my four year old laptop.</p>
							<p>Once you have the Dim_Demographics table in place, you may want to add its surrogate key back into the customer dimension as a Type 1 attribute to allow users to count customers based on their current mini-dimension values and report historical facts based on the current values. In this case, Dim_Demographics acts as an outrigger table on Dim_Customer. Again, the brute force method is easiest. You can join the Stage_Customer table which still contains the source attributes to Dim_Demographics on all the attributes that make up Dim_Demographics. This multi-join is obviously inefficient, but again, not as bad as it seems. Joining the same million plus row customer table to the 36 thousand row demographics table on all eight columns took 1 minute, 49 seconds on the virtual machine.</p>
							<p>Once all the dimension work is done, you will need to add the mini-dimension key into the fact row key lookup process. The easy way to do this during the daily incremental load is to return both the Dim_Customer surrogate key and the Dim_Demographic surrogate key as part of the customer business key lookup process.</p>
							<p><strong>Ongoing Mini-Dimension Maintenance</strong><br>
							Ongoing management of the dimension is a two-step process: first you have to add new rows to the Dim_Demographics table for any new values or combinations of values that show up in the incomingÂ Stage_Customer table. A simple brute force method leverages SQLâ€™s set based engine and the EXCEPT, or MINUS, function.</p>
							<p>INSERT INTO Dim_Demographics</p>
							<p>SELECT DISTINCT Payment_Type, Server_Group, Status_Type, Cancelled_Reason, Box_Type, Manufacturer, Box_Type_Descr, Box_Group_Descr FROM BigCustomer</p>
							<p>EXCEPT SELECT Payment_Type, Server_Group, Status_Type, Cancelled_Reason, Box_Type, Manufacturer, Box_Type_Descr, Box_Group_Descr FROM Dim_Demographics</p>
							<p>This should process very quickly because the engine simply scans the two tables and hash match the results. It took 7 seconds against the full source customer dimension in my sample data, and should be much faster with only the incremental data.</p>
							<p>Next, once all the attribute combinations are in place, you can add their surrogate keys to the incoming incremental rows. The same brute force, multi-column join method used to do the initial lookup will work here. Again, it should be faster because the incremental set is much smaller.</p>
							<p>By moving the Type 2 historical tracking into the fact table, you only connect a customer to their historical attribute values through the fact table. This may not capture a complete history of changes if customer attributes can change without an associated fact event.</p>
							<p>You may want to create a separate table to track these changes over time; this is essentially a factless fact table that would contain the customer, Dim_Demographics mini-dimension, change event date, and change expiration date keys. You can apply the same techniques we described in <a href="../../../2008/11/design-tip-107-using-the-sql-merge-statement-for-slowly-changing-dimension-processing/index.html">Design Tip #107</a> on using the SQL MERGE statement for slowly changing dimension processing to manage this table.</p>
							<p>NOTE: The original version of this design tip used a MERGE statement to identify new rows for the mini-dimension in the incremental processing step. The use of a MERGE statement in this case has the potential to allow duplicate rows in the mini-dimension. The EXCEPT statement in this updated version does not allow duplicates, and it works faster.</p>
							</div>
						</div>
					</div>
				</div>
			</div>
		</div>
		<script src="../../../resources/jquery.min.js"></script>
		<script src="../../../resources/menu.js"></script>
			
		
		<a id="scrollUp" href="../../../archive/bi/dwh/design-tip-127-creating-and-managing-mini-dimensions.html#top" title="Volver" style="position: fixed; z-index: 2147483647; display: none;">
			<i class="fa fa-chevron-up"></i>
		</a>
	</body>
</html>