

<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>Design Tip #142 Building Bridges</title>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta name="description">
		<meta name="application-name">
		<meta name="title">
		<link href="../../../favicon.ico" rel="shortcut icon" />
		<link rel="stylesheet" href="../../../resources/main.css">
	</head>
	

	<body>
	
		<div class="jumbotron1" id="jumbotron1">
			<div class="container">
				<h1 class="article-header">Design Tip #142 Building Bridges</h1>
				<div class="article-date">mi&#233;rcoles, 1 de febrero de 2012</div>
			</div>
		</div>
	
		<hr id="anchor-point"/>
		<div class="container-fluid">
			<a href="../../../archive/bi/dwh/design-tip-142-building-bridges.html#" class="navigationBars">
				<div class="iconBars closed">
					<span id="icon-bar1" class="iconBar colorChange background"></span>
					<span id="icon-bar2" class="iconBar colorChange background"></span>
					<span id="icon-bar3" class="iconBar colorChange background"></span>
				</div>
			</a>
			<div class="navLinks">
				<a id="link1" class="colorChange navLink link1" href="../../../index.html">Home</a>
				<a class="iconLink" href="../../../index.html"><i title="Home" id="icon1" class="fa fa-home colorChange link1"></i></a>
	
				<a id="link2" class="colorChange navLink link2" href="../../../about.html">Sobre mi</a>
				<a class="iconLink" href="../../../about.html"><i title="Sobre mi" id="icon2" class="fa fa-envelope colorChange link2"></i></a>

				<a id="link2" class="colorChange navLink link3" href="../../../archive.html">Archivo</a>
				<a class="iconLink" href="../../../about.html"><i title="Archivo" id="icon3" class="fa fa-archive colorChange link3"></i></a>
			</div>			
			
			<div class="row">
				<div class="content col-sm-8 col-sm-offset-2 col-xs-10 col-xs-offset-1">
					<div class="article">
						<p class="article-description"></p>				
						<div class="article-content">
							<div class="pf-content">
							<p>This Design Tip continues our series on how to implement common dimensional design patterns in yourÂ ETL system. The relationship between a fact table and its dimensions is usually many-to-one. That is, oneÂ row in a dimension, such as customer, can have many rows in the fact table, but one row in the fact tableÂ should belong to only one customer. However, there are times when a fact table row can be associatedÂ with more than one value in a dimension. We use a bridge table to capture this many-to-many relationship.</p>
							<p>There areÂ two major classes of bridge tables. The first, and easiest to model, captures a simpleÂ set of values associated with a single fact row. For example, an emergency room admittance record mayÂ have one or more initial disease diagnoses associated with it. There is no time variance in this bridge tableÂ because it captures the set of values that were in effect when the transaction occurred.</p>
							<p>The second kind of many-to-many relationship exists independent of the transactions being measured. TheÂ relationship between Customer and Account is a good example. A customer can have one or moreÂ accounts, and an account can belong to one or more customers, and this relationship can vary over time.</p>
							<p>This Design Tip covers the steps to create a simple static bridge table; this approach can be extended toÂ support the more complex time-variant bridge table.</p>
							<p><strong>Historical Load</strong><br>
							The steps involved in creating the historical bridge table depend on how the data is captured in the sourceÂ system. Our assumption is the source captures data that associates the multivalued set of dimension IDsÂ with each transaction ID. In the diagnosis example, this would be a table with one row for each admissionÂ record transaction ID and diagnosis ID. Note that this table will have more rows than the number ofÂ individual admission transactions.</p>
							<p><strong>Create the Initial List of Groups</strong><br>
							Since the source is normalized and has one row per dimension value, the first step is to create a unique listÂ of the groups of diagnoses that occur in the transaction table. This involves grouping the sets of diagnosesÂ together, de-duplicating the list of groups, and assigning a unique key to each group. This is often easiestÂ to do in SQL by creating a new table to hold the list of groups. Using the diagnosis example, Figure 1Â shows how the first few rows from the transaction system might be grouped and de-duplicated into the Diagnosis Group table.</p>
							<div style="" class="rs-gen-img img-rounded rs-no-border thumbnail pull-left wrap-no "><img src="../../../wp-content/uploads/2012/02/DT-142-Figure-1.png" class="rs-no-border img-rounded " alt="" title="" style=""></div><div class="clear"></div>
							<p>Figure 1 â€“Source transaction data and associated diagnosis group table.</p>
							<p>There are many ways to do this in the various dialects of SQL. The following version uses a stringÂ aggregation approach based on SQL Server T-SQL, using the STUFF() string function to do theÂ concatenation, the FOR XML PATH to collapse the rows into each transactionâ€™s set of codes, the SELECTÂ DISTINCT to create the unique list of groups, and the Row_Number() function to assign the group key.</p>
							<p>SELECT Row_Number() OVER ( ORDER BY Diagnosis_Code_List) AS<br>
							Diagnosis_Group_Key, Diagnosis_Code_List<br>
							INTO Diagnosis_Group<br>
							FROM(<br>
							SELECT DISTINCT Diagnosis_Code_List<br>
							FROM<br>
							(SELECT DISTINCT OuterTrans.ER_Admittance_ID,<br>
							STUFF((SELECT &#8216;, &#8216; + CAST(Diagnosis_Code AS VARCHAR(1024))<br>
							FROM ER_Admittance_Transactions InnerTrans<br>
							WHERE InnerTrans.ER_Admittance_ID = OuterTrans.ER_Admittance_ID<br>
							ORDER BY InnerTrans.Diagnosis_Code<br>
							FOR XML PATH(&#8221;)),1,2,&#8221;) AS Diagnosis_Code_List<br>
							FROM ER_Admittance_Transactions OuterTrans<br>
							) OuterList<br>
							) FinalList;</p>
							<p>Make sure your version of this code keeps the group lists in consistent order; in some cases the groupÂ â€˜T41.201, Z77.22â€™ is the same as the group â€˜Z77.22, T41.20â€™. In health care, the order is often importantÂ and both groups would be created; the source system must provide a sequence number which would beÂ included in the inner sort order and passed through to the bridge table. Note that the Diagnosis Group tableÂ is much shorter than the original source data. This is partly because weâ€™ve flattened the row set, but also because the number of combinations of values used in real life is often much smaller than the theoreticallyÂ possible combinations.</p>
							<p><strong>Create the Bridge Table</strong><br>
							Once weâ€™ve done the work to create the Diagnosis Group table and assign the group keys, we need to unpivotÂ it to create the actual Diagnosis Bridge table. This is the table that maps each group to the individualÂ dimension rows from which it is defined. Figure 2 shows the Diagnosis Bridge table and the associatedÂ ICD10_Diagnosis dimension table based on our example data.</p>
							<div style="" class="rs-gen-img img-rounded rs-no-border thumbnail pull-left wrap-no "><img src="../../../wp-content/uploads/2012/02/DT-142-Figure-2.png" class="rs-no-border img-rounded " alt="" title="" style=""></div><div class="clear"></div>
							<p>Figure 2 â€“Diagnosis Bridge table and associated ICD10_Diagnosis dimension.</p>
							<p>Again, there are many ways to accomplish this in SQL. The following version in SQL Server T-SQL uses aÂ two-step process to unpivot the group table. The first step concatenates XML tags (&lt;I&gt; &lt;/I&gt;) into theÂ Diagnosis_Code_List and converts it to an XML datatype as part of a common table expression. TheÂ second step uses the CROSS APPLY command to parse out the XML tags and list the values on separateÂ lines.</p>
							<p>WITH XMLTaggedList AS (<br>
							SELECT Diagnosis_Group_Key,<br>
							CAST(&#8216;&lt;I&gt;&#8217; + REPLACE(Diagnosis_Code_List, &#8216;, &#8216;, &#8216;&lt;/I&gt;&lt;I&gt;&#8217;) + &#8216;&lt;/I&gt;&#8217; AS XML)<br>
							AS Diagnosis_Code_List<br>
							FROM Diagnosis_Group<br>
							)<br>
							SELECT Diagnosis_Group_Key,<br>
							ExtractedDiagnosisList.X.value(&#8216;.&#8217;, &#8216;VARCHAR(MAX)&#8217;) AS Diagnosis_Code_List<br>
							FROM XMLTaggedList<br>
							CROSS APPLY Diagnosis_Code_List.nodes(&#8216;//I&#8217;) AS ExtractedDiagnosisList(X);</p>
							<p><strong>Incremental Processing</strong><br>
							The incremental load process applies essentially the same code to the incoming fact rows. The first stepÂ generates a Diagnosis_Code_List column for each group of incoming fact rows at the grain of the factÂ table. This Diagnosis_Code_List value can then be used to join to the Diagnosis_Group table to mapÂ incoming fact rows to the appropriate group key. If a new group shows up, the ETL process will need toÂ add it the Diagnosis_Group table, just like it does for mini-dimensions and junk dimensions.</p>
							<p>Weâ€™ve used SQL to illustrate the design pattern used in creating a bridge table. The same logic could beÂ implemented in the native syntax and control structures of most ETL tools. Of course, if would be ideal ifÂ the ETL tool developers built bridge table processing into their toolset rather than forcing us all to reinventÂ the wheel. Maybe theyâ€™ll put it in the next release. If youâ€™d like the SQL script for this example, send me aÂ note.</p>
							<p>NOTE: This Design Tip has been updated from the original to include a surrogate key on the ICD10_Diagnosis table.</p>
							</div>
						</div>
					</div>
				</div>
			</div>
		</div>
		<script src="../../../resources/jquery.min.js"></script>
		<script src="../../../resources/menu.js"></script>
			
		
		<a id="scrollUp" href="../../../archive/bi/dwh/design-tip-142-building-bridges.html#top" title="Volver" style="position: fixed; z-index: 2147483647; display: none;">
			<i class="fa fa-chevron-up"></i>
		</a>
	</body>
</html>