

<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>The Soul of the Data Warehouse, Part 2: Drilling Across</title>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta name="description">
		<meta name="application-name">
		<meta name="title">
		<link href="../../../favicon.ico" rel="shortcut icon" />
		<link rel="stylesheet" href="../../../resources/main.css">
	</head>
	

	<body>
	
		<div class="jumbotron1" id="jumbotron1">
			<div class="container">
				<h1 class="article-header">The Soul of the Data Warehouse, Part 2: Drilling Across</h1>
				<div class="article-date">s&#225;bado, 5 de abril de 2003</div>
			</div>
		</div>
	
		<hr id="anchor-point"/>
		<div class="container-fluid">
			<a href="../../../archive/bi/dwh/the-soul-of-the-data-warehouse-part-two-drilling-across.html#" class="navigationBars">
				<div class="iconBars closed">
					<span id="icon-bar1" class="iconBar colorChange background"></span>
					<span id="icon-bar2" class="iconBar colorChange background"></span>
					<span id="icon-bar3" class="iconBar colorChange background"></span>
				</div>
			</a>
			<div class="navLinks">
				<a id="link1" class="colorChange navLink link1" href="../../../index.html">Home</a>
				<a class="iconLink" href="../../../index.html"><i title="Home" id="icon1" class="fa fa-home colorChange link1"></i></a>
	
				<a id="link2" class="colorChange navLink link2" href="../../../about.html">Sobre mi</a>
				<a class="iconLink" href="../../../about.html"><i title="Sobre mi" id="icon2" class="fa fa-envelope colorChange link2"></i></a>

				<a id="link2" class="colorChange navLink link3" href="../../../archive.html">Archivo</a>
				<a class="iconLink" href="../../../about.html"><i title="Archivo" id="icon3" class="fa fa-archive colorChange link3"></i></a>
			</div>			
			
			<div class="row">
				<div class="content col-sm-8 col-sm-offset-2 col-xs-10 col-xs-offset-1">
					<div class="article">
						<p class="article-description"></p>				
						<div class="article-content">
							<div class="pf-content">
							<p>The three fundamental themes that make up the soul of every data warehouse are drilling down, drilling across, and handling time. In Part One of &#8220;The Soul of the Data Warehouse,&#8221; I showed that drilling down was nothing more than adding a row header,Â <em>any row header</em>, to an existing query. Although we often grouse about SQL&#8217;s limitations as a report writer, when it comes to drilling down, SQL gracefully expands an existing query whenever a new row header is added. This simple result led to the powerful realization that when data is organized in a symmetrical, predictable fashion starting at the most atomic level, all queries and applications benefit.</p>
							<p>If drilling down is the most fundamental maneuver in a data warehouse, drilling across is a close second. From the perspective of an answer set, drilling acrossÂ <em>adds more data to an existing row.</em>Â Note that this result isn&#8217;t what you get from aÂ <code>UNION</code>Â of rows from separate queries. It&#8217;s better described as the column accretion from separate queries.</p>
							<p>Drilling across by adding another measured fact to theÂ <code>SELECT</code>Â list from the existing fact table mentioned in the query is a trivial accomplishment. What&#8217;s more interesting and important is adding another measured fact from a new fact table.</p>
							<p>The issues raised by this simple view of drilling across are at the heart of data warehouse architecture. These issues boil down to an observation and a choice.</p>
							<p><strong>Drill-across observation:</strong>Â The new fact table called for in the drill-across operation must share certain dimensions with the fact table in the original query.</p>
							<p>Certain dimensions will be named in the original query because they contribute row headers. Remember that these row headers are the basis of the grouping that creates the answer-set row. These dimensions will appear in theÂ <code>FROM</code>Â clause of the SQL code and will be joined to the fact table through the relationship of a foreign key to primary key. The new fact table must also support exactly these same row headers, or the context of the answer-set row is meaningless.</p>
							<p><strong>Drill-across choice:</strong>Â Either send a single, simultaneous SQL request to the two fact tables or send two separate requests.</p>
							<p>Although sending a single SQL request to the two fact tables seems cleaner, this choice can become a showstopper. Sending a single request means mentioning both fact tables in theÂ <code>FROM</code>clause of the SQL code and joining both fact tables in some way to the common dimension tables I just discussed. This commingling of two fact tables in the same SQL statement causes these problems:</p>
							<ul>
							<li>Because the two fact tables will be joined together either directly or through the common dimensions, the query must specify whether the many-to-many relationship between the two fact tables is handled with inner or outer joins. This fundamental challenge arises from the relational model. It&#8217;s effectively impossible to get this right, even if you&#8217;re an expert SQL programmer. Depending on the relative cardinality of the two fact tables, your aggregated numeric totals can either be too low or too high, or both! Even if you don&#8217;t believe me, you have to deal with the next bullet point.</li>
							<li>The vast majority of queries the relational database receives are generated by powerful query tools and report writers, and you have no direct control over the SQL they emit. You don&#8217;tÂ <em>want</em>Â control over the SQL. Some of these tools generate mind-boggling reams of SQL and you can&#8217;t effectively intervene.</li>
							<li>Emitting a single SQL statement precludes you from requesting data from separate table spaces, separate machines, or separate database vendors. You&#8217;re stuck in the same table space on the same machine talking to one database vendor. If you can easily avoid this problem, why take on these restrictions?</li>
							<li>Finally, if you emit a single SQL statement involving both fact tables, you&#8217;ll almost certainly be unable to use any of the powerful query-rewrite tools that performÂ <em>aggregate navigation</em>.</li>
							</ul>
							<p>&nbsp;</p>
							<h4>Implementing Drill-Across</h4>
							<p>If you&#8217;ve followed the logic of the observation and the choice, the architecture to support drill-across begins to emerge. I use some modern data warehouse words to describe the two key aspects of this architecture:</p>
							<ol>
							<li>All fact tables in a drill-across query must useÂ <em>conformed dimensions</em>.</li>
							<li>The actual drill-across query consists of aÂ <em>multi-pass</em>Â set of separate requests to the target fact tables followed by a simpleÂ <em>sort/merge</em>Â on the identical row headers returned from each request.</li>
							</ol>
							<p>The simplest definition of conformed dimensions is that two instances of a conformed dimension are identical. So if two fact tables have a &#8220;Customer&#8221; dimension, then &#8220;Customer&#8221; is conformed if the two dimensions are exactly the same. But this definition is unnecessarily restrictive. Here&#8217;s the precise definition of conformed dimensions:Â <em>Two dimensions are conformed if the fields that you use as common row headers have the same domain.</em></p>
							<p>When you bring two separate queries together in a drill-across operation, both queries must have the same number of row headers, arranged from left to right in the same order. All the rest of the columns (the computed facts) in the two queries, by definition, are not row headers. In other words, an independent examination of both queries shows that neither query has rows that duplicate the same row headers. To put it another way, the row headers form a unique key for each row of the answer set.</p>
							<p>To sort/merge the two queries, you must sort them the same way. At this point, it becomes possible to merge the rows of the two queries together in a single pass. The resulting merged answer set has a single set of row headers plus the combined set of computed facts returned from both queries. Because traditional sort/merge is the same as an outer join, it is possible for a row in the final merged answer set to have nulls for either the first set of computed facts or the second set, but not both!</p>
							<p>Once you&#8217;ve visualized the sort/merge step in drilling across, you really understand conformed dimensions. With conformed dimensions, the only thing you care about is matching row headers. If the contents of the respective fields you&#8217;re using for the sort/merge are drawn from the same domains, then the match makes sense. If you try to match row headers from two dimensions that aren&#8217;t conformed, you&#8217;re guaranteed to get garbage. The sort/merge will fail, and the SQL engine will post the results from the two queries on separate lines â€” and probably in separate sorting locations in the merged answer set.</p>
							<h4>Amazing Magic</h4>
							<p>In my classes, I sometimes describe conformed dimensions as either dimensions that are exactly equal (the trivial case) or dimensions where &#8220;one is a subset of the other.&#8221; For example, a brand dimension may be a subset of a more detailed product dimension. In this case, you can drill across two fact tables, one at the brand level with a brand dimension (such as a forecast), and the other at a detailed product level with a product dimension (such as sales transactions). Assume that the product dimension is a nice flat table containing the low cardinality brand attribute.</p>
							<p>If the row header of the two queries is simply &#8220;brand,&#8221; then some amazing magic takes place. The engine automatically aggregates both data sets to the brand level, which is exactly the right level for the drill-across. If the names of the brands are drawn from the same domain, you can complete the drill-across (of forecast vs. actual) by confidently merging the rows with the same brand names. Many commercial query and report-writing tools perform this drill-across operation.</p>
							<p>You can see that it&#8217;s possible to conform two dimensions even when they have some incompatible fields. You just need to be careful to avoid using these incompatible fields as row headers in drill-across queries. Not avoiding it lets a dimension contain some private fields that are meaningful only to a local user group.</p>
							<h4>Centralizing vs. Conforming</h4>
							<p>One final thought: In a recent column, my colleague Margy Ross pointed out that the decision to physically centralize a data warehouse has very little to do with conformed dimensions. Her point was that if you combine two data sets in a drill-across operation, you have to label them the same way, which is true whether the data sets are tightly administered on a single piece of hardware by one DBA or are loosely administered by remote IT organizations that merely agree to create a set of overlapping labels.</p>
							</div>
						</div>
					</div>
				</div>
			</div>
		</div>
		<script src="../../../resources/jquery.min.js"></script>
		<script src="../../../resources/menu.js"></script>
			
		
		<a id="scrollUp" href="../../../archive/bi/dwh/the-soul-of-the-data-warehouse-part-two-drilling-across.html#top" title="Volver" style="position: fixed; z-index: 2147483647; display: none;">
			<i class="fa fa-chevron-up"></i>
		</a>
	</body>
</html>